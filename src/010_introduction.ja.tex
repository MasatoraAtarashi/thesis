\chapter{序論}
\label{chap:introduction}

\section{本研究の背景}

低消費電力デバイスの性能向上と低価格化により、身の回りの家具や家電をはじめとしたあらゆるものがインターネットに接続し、
協調して動作することで生活を豊かにするInternet of Things（IoT）が普及しつつある。

また、低消費電力デバイスの性能向上は、これらの上にTLSやHTTPといった比較的高負荷・高フットプリントなプロトコルを実装することも可能とした。
これにより、端末間の接続、また端末とデータを集約するサーバとの接続に汎用的なプロトコルを用いることができるようになり、高い相互接続性を実現できるようになった。

また、単一のチップでWi-FiやBluetooth、Bluetooth Low Energy（BLE）による接続を提供するものも登場している。
こうした端末を用いることで、電波環境や電力消費といったリソースを効率的に利用することが可能なため、IoTシステムを適用できる環境は大きく広がっている。

たとえば、Espressif Systems社のESP32\cite{esp32}は、以下の仕様を持っている。

\begin{itemize}
  \item Xtensa single-/dual-core 32-bit LX6 microprocessor(s), up to 600 MIPS
  \item 448 KB ROM, 536 KB SRAM
  \item QSPI supports multiple flash/SRAM chips
  \item 802.11 b/g/n
\end{itemize}


一方で、各デバイス上で動作するソフトウェアは、依然としてそれぞれの開発環境に合わせて実装する必要がある。
x86やARMといったアーキテクチャが一般に用いられる個人向けコンピュータやサーバと異なり、低消費電力デバイスが搭載するマイクロコントローラの
アーキテクチャは多岐にわたる。また、サポートされているコンパイラもそれぞれに異なり、開発者はデバイス毎に切り替えて開発を行わなければならない。

（FreeRTOSがサポートするマイコンのアーキテクチャ一覧の表？）

\section{本研究の目的}

本研究の目的は、異なるCPUアーキテクチャを搭載した低消費電力デバイス間で、同一のWebAssemblyバイナリを実行できることを示すことである。

一般に、複数のアーキテクチャで共通のバイナリを実行することは、それぞれのアーキテクチャ向けにコンパイルされたバイナリを実行するよりも
オーバーヘッドが大きく、CPUの性能やメモリの容量が限られている低消費電力デバイスには向かない。

そこで本研究では、低消費電力デバイスでも低オーバーヘッドで実行可能なバイナリ表現としてWebAssemblyを用いることを提案する。
まず、既存の手法（JVM、CPUエミュレーション）と比べ、また実行環境の実装が容易であること、少ないオーバーヘッドで実行できることを示す。
続いて、C言語でクロスプラットフォームなWebAssemblyランタイムを実装し、ESP32と（ラズパイ？）で同一のバイナリを実行することで、
異なる低消費電力デバイスで同一のバイナリを実行できることを示す。

\section{本研究が対象とする環境}

RFC 7228\cite{rfc7228}では、CPU、メモリおよび電力といったリソースにおいて強い制約を持つデバイスを
{\it constrained device}として定義し、いくつかの{\it class}に分類している。

\begin{itembox}[l]{とりあえずコピペした表}
\begin{verbatim}
+-------------+-----------------------+-------------------------+
| Name        | data size (e.g., RAM) | code size (e.g., Flash) |
+-------------+-----------------------+-------------------------+
| Class 0, C0 | << 10 KiB             | << 100 KiB              |
|             |                       |                         |
| Class 1, C1 | ~ 10 KiB              | ~ 100 KiB               |
|             |                       |                         |
| Class 2, C2 | ~ 50 KiB              | ~ 250 KiB               |
+-------------+-----------------------+-------------------------+
\end{verbatim}
\end{itembox}

本研究では、ある程度使用できるリソースに制約を持ちながら、すでに広く用いられているプロトコルスタック（TCP/IP、HTTP、TLSなど）を
利用できる程度のリソースを持つ、{\it Class 2}以上のデバイスを想定している。

\begin{quote}
  Class 2 devices are less constrained and fundamentally capable of
  supporting most of the same protocol stacks as used on notebooks or
  servers
\end{quote}

\section{本研究の構成}

本論文における以降の構成は次の通りである。

\ref{chap:related_works}章では、異なるCPUアーキテクチャで同一のバイナリを実行するための既存の手法を示す。
\ref{chap:comparison}章では、既存の各手法では低消費電力デバイスでの利用が難しいことを示し、WebAssemblyを用いる利点について述べる。
\ref{chap:implementation}章では、本研究で実装するWebAssemblyランタイムとそれを実行するプログラムについて、設計と実装を示す。
\ref{chap:evaluation}章では、本研究の実装の有効性を評価し、その結果を考察する。
\ref{chap:conclusion}章では、本研究の結論についてまとめるとともに、今後の展望を示す。
