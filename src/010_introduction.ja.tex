\chapter{序論}
\label{chap:introduction}

\section{本研究の背景}

低消費電力デバイスの性能向上と低価格化により、身の回りの家具や家電をはじめとしたあらゆるものがインターネットに接続し、
協調して動作することで生活を豊かにするInternet of Things（IoT）が普及しつつある。

また、低消費電力デバイスの性能向上は、これらの上にTLSやHTTPといった比較的高負荷・高フットプリントなプロトコルを実装することも可能とした。
これにより、端末間の接続、また端末とデータを集約するサーバとの接続に汎用的なプロトコルを用いることができるようになり、高い相互接続性を実現できるようになった。

また、単一のチップでWi-FiやBluetooth、Bluetooth Low Energy（BLE）による接続を提供するものも登場している。
こうした端末を用いることで、電波環境や電力消費といったリソースを効率的に利用することが可能なため、IoTシステムを適用できる環境は大きく広がっている。

たとえば、Espressif Systems社のESP32\cite{esp32}は、以下の仕様を持っている。

\begin{itemize}
  \item Xtensa single-/dual-core 32-bit LX6 microprocessor(s), up to 600 MIPS
  \item 448 KB ROM, 536 KB SRAM
  \item QSPI supports multiple flash/SRAM chips
  \item 802.11 b/g/n
\end{itemize}


一方で、各デバイス上で動作するソフトウェアは、依然としてそれぞれの開発環境に合わせて実装する必要がある。
x86やARMといったアーキテクチャが一般に用いられる個人向けコンピュータやサーバと異なり、低消費電力デバイスが搭載するマイクロコントローラの
アーキテクチャは多岐にわたる。また、サポートされているコンパイラもそれぞれに異なり、開発者はデバイス毎に切り替えて開発を行わなければならない。

（FreeRTOSがサポートするマイコンのアーキテクチャ一覧の表？）

\section{本研究の目的}

本研究の目的は、異なるCPUアーキテクチャを搭載した低消費電力デバイス間で、同一のWebAssemblyバイナリを実行できることを示すことである。

一般に、複数のアーキテクチャで共通の実行形式を実行することは、それぞれのアーキテクチャ向けにコンパイルされた実行形式を実行するよりも
オーバーヘッドが大きく、CPUの性能やメモリの容量が限られている低消費電力デバイスには向かない。

そこで本研究では、低消費電力デバイスでも低オーバーヘッドで実行形式としてWebAssemblyを用いることを提案する。
まず、既存の手法（JVM、CPUエミュレーション）と比べ、また実行環境の実装が容易であること、少ないオーバーヘッドで実行できることを示す。
続いて、C言語でクロスプラットフォームなWebAssemblyランタイムを実装し、ESP32（とラズパイ？）で同一の実行形式を実行することで、
異なるアーキテクチャを持つ低消費電力デバイスにおける共通の実行形式としてWebAssemblyが有効であることを示す。

\section{本研究が対象とする環境}

RFC 7228\cite{rfc7228}では、CPU、メモリおよび電力といったリソースにおいて強い制約を持つデバイスを
制約されたデバイス（{\it constrained device}）として定義し、いくつかのクラス（{\it class}）に分類している。
クラスの一覧を表\ref{tb:rfc7228}に示した。

\begin{table}[htbp]
  \caption{RFC 7228におけるクラスの分類}
  \label{tb:rfc7228}
  \begin{center}
    \begin{tabular}{|l|l|l|}
      \hline
      クラス名 & データ格納領域のサイズ（RAMなど） & コード格納領域のサイズ（ROMなど） \\ \hline
      クラス 0（C0） & 10KiBよりはるかに小さい & 100KiB よりはるかに小さい \\ \hline
      クラス 1（C1） & 10KiB 程度 & 100KiB 程度 \\ \hline
      クラス 2（C2） & 50KiB 程度 & 250KiB 程度 \\ \hline
    \end{tabular}
  \end{center}
\end{table}

本研究では、ある程度使用できるリソースに制約を持ちながら、すでに広く用いられているプロトコルスタック（TCP/IP、HTTP、TLSなど）を
利用できる程度のリソースを持つ、クラス2以上のデバイスを想定している。

\section{本研究の構成}

本論文における以降の構成は次の通りである。

\ref{chap:related_works}章では、異なるCPUアーキテクチャで同一のバイナリを実行するための既存の手法を示す。
\ref{chap:comparison}章では、既存の各手法では低消費電力デバイスでの利用が難しいことを示し、WebAssemblyを用いる利点について述べる。
\ref{chap:implementation}章では、本研究で実装するWebAssemblyランタイムとそれを実行するプログラムについて、設計と実装を示す。
\ref{chap:evaluation}章では、本研究の実装の有効性を評価し、その結果を考察する。
\ref{chap:conclusion}章では、本研究の結論についてまとめるとともに、今後の展望を示す。
