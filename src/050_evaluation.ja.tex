\chapter{評価}
\label{chap:evaluation}

本章では、ESP32マイコンとPC上で同一のWebAssemblyプログラムを実行することで、それぞれの環境における実行性能を比較し、マイコンにおけるWebAssembly実行環境の性能を考察する。

\section{評価手法}

\subsection{WebAssemblyバイナリ}
\label{subsec:wasm}

各実行環境で実行する同一のWebAssemblyプログラムとして、与えられた整数$n$に対して$n+1$番目のフィボナッチ数を返す関数$fib(n)$をC言語で実装した。

\begin{itembox}[l]{フィボナッチ関数のC言語による実装}
  \begin{verbatim}
    int fib(int n) {
      if (n <= 1) return 1;
      return fib(n - 1) + fib(n - 2);
    }
  \end{verbatim}
\end{itembox}

この関数のコンパイルには、LLVM/Clang 7.0.1を用いた。
LLVMのWebAssembly対応は試験的なものであるため、LLVMおよびClangコンパイラ自体を{\tt LLVM\_EXPERIMENTAL\_TARGETS\_TO\_BUILD}フラグに{\tt WebAssembly}を指定してソースコードからビルドした。

このLLVM/Clangを用いて{\tt fib}関数をコンパイルし、85バイトのWebAssemblyバイナリを得た。
WebAssemblyバイナリのコンパイル時に設定したオプションを表\ref{tab:compiler}に示す。

\begin{table}[htbp]
  \label{tab:compiler}
  \caption{ESP32環境の構成}
  \begin{center}
    \begin{tabular}{|l|l|}
    \hline
    --target=wasm32-unknown-unknown-wasm & wasm32バイナリを生成する \\ \hline
    -s & バイナリサイズを最適化（デバッグ情報などを含めない） \\ \hline
    -O3 & プログラムを最大レベルで最適化 \\ \hline
    -nostdlib -nostartfiles & 標準起動ファイルや標準ライブラリを用いない \\ \hline
    --fvisibility=default & 全ての関数をモジュール外から参照可能にする \\ \hline
    -Wl,--no-entry & エントリーポイント（{\tt \_start}）が無いことを警告しない \\ \hline
    \end{tabular}
  \end{center}
\end{table}

以下全ての実行性能の比較に、\verb|fib|関数をコンパイルしたWebAssemblyバイナリを用いた。

\subsection{ESP32環境}

\ref{subsec:wasm}項の方法によりコンパイルしたWebAssemblyバイナリを、\ref{chap:implementation}章で述べたESP32上のホストプログラムに埋め込み、libwasmを用いて0から30までの$n$について関数を呼び出した。

ESP32環境の構成を表\ref{tab:esp_spec}に示す。

\begin{table}[htbp]
  \label{tab:esp_spec}
  \caption{ESP32環境の構成}
  \begin{center}
    \begin{tabular}{|l|l|}
    \hline
    ハードウェア & ESP32-WROOM-32 \\ \hline
    プロセッサ & Tensilica Xtensa LX6 (240MHz, dual-core) \\ \hline
    OS & ESP-IDF FreeRTOS v3.3-beta1-223-ga62cbfec9 \\ \hline
    コンパイラ & GCC 5.2.0 (crosstool-NG 1.22.0-80-g6c4433a) \\ \hline
    \end{tabular}
  \end{center}
\end{table}

実行速度は、ESP-IDFが提供する\verb|esp_timer_get_time|関数を用いて計測した。
ESP-IDFを用いてコンパイルされたプログラムは、起動後\verb|esp_timer_init|関数を自動的に呼び出し、タイマーを初期化する。
\verb|esp_timer_get_time|関数は、このタイマーが初期化されてからの経過時間をマイクロ秒単位で返す。
0から13までの各$n$について、\verb|fib|関数の実行直前および実行直後に\verb|esp_timer_get_time|関数を呼び出し、差分を実行時間とした。

また、メモリフットプリントの計測には、FreeRTOSがAPIとして提供する \\
\verb|xPortGetMinimumEverFreeHeapSize|関数を用いた。
この関数は、起動以降一度も確保されていないヒープ領域の最小のサイズを返す。
すなわち、この値の減少分が、処理に必要なメモリフットプリントの増加分と言える。
そこで、モジュールのインスタンス化直後にこの関数で計測した値を0とし、フィボナッチ関数を実行した後の同関数が返す値との差分を取り、関数実行におけるメモリフットプリントとした。

\subsection{macOS環境}

ESP32環境と同様に、\ref{subsec:wasm}項の方法によりコンパイルしたWebAssemblyバイナリをmacOS上でlibwasmにより実行するプログラムを実装し、0から30までの$n$について関数を呼び出した。
macOS環境の構成を表\ref{tab:mac_spec}に示す。

\begin{table}[htbp]
  \label{tab:mac_spec}
  \caption{macOS環境の構成}
  \begin{center}
    \begin{tabular}{|l|l|}
    \hline
    ハードウェア & Mac mini (2018) \\ \hline
    プロセッサ & Intel Core i5 (3 GHz, 6 cores) \\ \hline
    OS & macOS 10.14.1 \\ \hline
    コンパイラ & Apple LLVM version 10.0.0 (clang-1000.11.45.5) \\ \hline
    \end{tabular}
  \end{center}
\end{table}

実行速度の計測には、OSが提供する\verb|clock_gettime|関数を用いた。
クロックの種別には \\
\verb|CLOCK_MONOTONIC|を指定し、時刻設定に関わらず単調増加する時間をナノ秒精度で取得した。

\subsection{ブラウザ環境}

macOS環境と同じOSおよびハードウェア上で、WebブラウザによるWebAssembly実行性能を計測した。
Webページのスクリプト内でWebAssemblyバイナリを読み込み、同様に0から30までの$n$について関数を呼び出した。Webブラウザには、OS標準のSafari 12.0.1（14606.2.104.1.1）を用いた。

実行時間の計測には、標準化されたWeb APIであるPerformance APIを用いた。
JavaScriptから\verb|performance.now|関数を実行することで、仕様上はマイクロ秒の精度でタイムスタンプを得られる。
しかし、いわゆるSpectreと呼ばれる脆弱性への対策として、WebKitでは\verb|performance.now|の精度がミリ秒単位に丸められている\cite{webkit_spectre}\cite{webkit_trac}。
そこで、各$n$について\verb|fib(n)|を10000回ずつ実行し、その平均を実行時間の計測値として用いた。

\section{実行速度}

0から30までの各$n$について\verb|fib|関数を実行した時の時間と、macOS環境に対してESP32環境で実行に必要なクロック数を表\ref{tab:fib_time}に示した。
実行に必要なクロック数の比較は、各環境で計測された実行時間にそれぞれのCPUのクロック周波数を乗じ、比を求めた。
すなわち、ESP32環境における実行はmacOS環境における実行に対して、$n=0$や$n=1$の時に約7倍、$n=10$の時に約11倍、$n=30$の時に約15倍のクロック数が必要だった。

続いて、ブラウザ環境における実行性能を計測した。ブラウザはmacOS環境と同じアーキテクチャにJITコンパイルされるため、求めたESP32環境とmacOS環境における実行性能の比を用いて、ESP32においてブラウザと同等の実行効率が得られた際の実行性能を近似して推測することができる。

計測したブラウザ環境における実行時間と、推測したESP32における性能を表\ref{tab:fib_time_browser}に示す。ESP32においてブラウザと同等の実行効率が得られた場合、$n=10$の時に約29マイクロ秒、$n=30$の時に約560ミリ秒の実行時間となることが推測された。

\begin{table}[htbp]
  \caption{libwasmを用いた{\tt fib}関数の実行時間（マイクロ秒）と、必要なクロック数の比}
  \label{tab:fib_time}
  \begin{center}
    \begin{tabular}{|r|r|r||r||r|r|r||r|}
\hline
& Mac mini & ESP32 & 必要クロック数 & & Mac mini & ESP32 & 必要クロック数 \\ \hline
0  &     3 &     267 &  7.1 倍 & 16 &     8,608 &     1,178,811 & 10.9 倍 \\ \hline
1  &     3 &     259 &  6.9 倍 & 17 &    13,815 &     1,933,996 & 11.2 倍 \\ \hline
2  &     9 &     916 &  7.8 倍 & 18 &    22,328 &     3,172,256 & 11.3 倍 \\ \hline
3  &    15 &   1,564 &  8.1 倍 & 19 &    35,609 &     5,202,283 & 11.6 倍 \\ \hline
4  &    25 &   2,799 &  8.9 倍 & 20 &    52,961 &     8,529,805 & 12.8 倍 \\ \hline
5  &    42 &   4,742 &  9.0 倍 & 21 &    83,772 &    13,983,115 & 13.3 倍 \\ \hline
6  &    70 &   7,994 &  9.0 倍 & 22 &   134,115 &    22,918,957 & 13.6 倍 \\ \hline
7  &   118 &  13,302 &  9.0 倍 & 23 &   216,433 &    37,558,837 & 13.8 倍 \\ \hline
8  &   161 &  22,046 & 10.9 倍 & 24 &   349,573 &    61,540,310 & 14.0 倍 \\ \hline
9  &   287 &  36,400 & 10.1 倍 & 25 &   562,661 &   100,818,119 & 14.3 倍 \\ \hline
10 &   408 &  59,973 & 11.7 倍 & 26 &   909,827 &   165,139,586 & 14.5 倍 \\ \hline
11 &   648 &  98,676 & 12.1 倍 & 27 & 1,455,711 &   270,457,743 & 14.8 倍 \\ \hline
12 & 1,432 & 162,208 &  9.0 倍 & 28 & 2,353,144 &   442,878,521 & 15.0 倍 \\ \hline
13 & 2,354 & 266,487 &  9.0 倍 & 29 & 3,847,535 &   725,117,084 & 15.0 倍 \\ \hline
14 & 3,642 & 437,590 &  9.6 倍 & 30 & 6,237,998 & 1,187,057,130 & 15.2 倍 \\ \hline
15 & 5,022 & 718,329 & 11.4 倍 & & & & \\ \hline
    \end{tabular}
  \end{center}
\end{table}

\begin{table}[htbp]
  \caption{Webブラウザにおける実行時間と、推測されるESP32上での実行時間（マイクロ秒）}
  \label{tab:fib_time_browser}
  \begin{center}
    \begin{tabular}{|r|r|r||r|r|r|}
      \hline
      & Webブラウザ & ESP32（推測） & & Webブラウザ & ESP32（推測） \\ \hline
       0 &     0 &       9 & 16 &     4 &     534 \\ \hline
       1 &     0 &       0 & 17 &     6 &     812 \\ \hline
       2 &     0 &      10 & 18 &    10 &   1,350 \\ \hline
       3 &     0 &      10 & 19 &    15 &   2,235 \\ \hline
       4 &     0 &      11 & 20 &    24 &   3,898 \\ \hline
       5 &     0 &      11 & 21 &    39 &   6,543 \\ \hline
       6 &     0 &      11 & 22 &    63 &  10,715 \\ \hline
       7 &     0 &      11 & 23 &   102 &  17,666 \\ \hline
       8 &     0 &      14 & 24 &   168 &  29,646 \\ \hline
       9 &     0 &      25 & 25 &   272 &  48,755 \\ \hline
      10 &     0 &      29 & 26 &   431 &  78,302 \\ \hline
      11 &     0 &      61 & 27 &   697 & 129,533 \\ \hline
      12 &     1 &      68 & 28 & 1,127 & 212,015 \\ \hline
      13 &     1 &     113 & 29 & 1,818 & 342,625 \\ \hline
      14 &     2 &     180 & 30 & 2,941 & 559,694 \\ \hline
      15 &     3 &     358 &    &       &         \\ \hline
    \end{tabular}
  \end{center}
\end{table}

\section{メモリフットプリント}

ESP32環境での実行について、メモリフットプリントとしてヒープ領域に確保されるメモリの最大量を計測した。
引数\verb|n|を0から13まで変化させた際の、関数実行のメモリフットプリントの推移を表\ref{tab:heap_size}に示す。

定数を返すのみである$n=0$および$n=1$の時、メモリフットプリントは540バイトで、実行速度と同様に変化はなかった。
再帰的な関数呼び出しが発生する$n=2$以降は、208バイトずつ上昇していった。
これは、WebAssembly実行環境のスタックにおけるメモリ消費であると考えられる。

\begin{table}[htbp]
  \caption{ESP32環境におけるメモリフットプリントの推移（バイト）}
  \label{tab:heap_size}
  \begin{center}
    \begin{tabular}{|r|r|r|r|}
      \hline
      & 未確保領域 & 起動からの確保量 & フットプリントの増加 \\ \hline
      起動後      & 294,460 & 0 & - \\ \hline
      パース後     & 294,424 & 36 & 36 \\ \hline
      インスタンス化後 & 294,264  & 196 & 160 \\ \hline
      $n=0$  & 293,920 &   540 & 344 \\ \hline
          1  & 293,920 &   540 &   0 \\ \hline
          2  & 293,640 &   820 & 280 \\ \hline
          3  & 293,360 & 1,100 & 280 \\ \hline
          4  & 293,080 & 1,380 & 280 \\ \hline
          5  & 292,800 & 1,660 & 280 \\ \hline
          6  & 292,520 & 1,940 & 280 \\ \hline
          7  & 292,240 & 2,220 & 280 \\ \hline
          8  & 291,960 & 2,500 & 280 \\ \hline
          9  & 291,680 & 2,780 & 280 \\ \hline
          10 & 291,400 & 3,060 & 280 \\ \hline
          11 & 291,120 & 3,340 & 280 \\ \hline
          12 & 290,840 & 3,620 & 280 \\ \hline
          13 & 290,560 & 3,900 & 280 \\ \hline
    \end{tabular}
  \end{center}
\end{table}
